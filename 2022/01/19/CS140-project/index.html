<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>CS140 - Pintos Projects | Lfalive's Blog</title><meta name="keywords" content="concurrency stanford pintos bochs CS140 qemu"><meta name="author" content="Lfalive"><meta name="copyright" content="Lfalive"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="斯坦福大学CS140 Pintos操作系统课程Project1">
<meta property="og:type" content="article">
<meta property="og:title" content="CS140 - Pintos Projects">
<meta property="og:url" content="https://lfalive.github.io/2022/01/19/CS140-project/index.html">
<meta property="og:site_name" content="Lfalive&#39;s Blog">
<meta property="og:description" content="斯坦福大学CS140 Pintos操作系统课程Project1">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://img.lfalive.top/CS140-project/cover.png">
<meta property="article:published_time" content="2022-01-18T16:00:00.000Z">
<meta property="article:modified_time" content="2022-01-25T14:55:16.187Z">
<meta property="article:author" content="Lfalive">
<meta property="article:tag" content="concurrency">
<meta property="article:tag" content="stanford">
<meta property="article:tag" content="pintos">
<meta property="article:tag" content="bochs">
<meta property="article:tag" content="qemu">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://img.lfalive.top/CS140-project/cover.png"><link rel="shortcut icon" href="https://img.lfalive.top/favicon.png"><link rel="canonical" href="https://lfalive.github.io/2022/01/19/CS140-project/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//hm.baidu.com"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://unpkg.zhimg.com/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://unpkg.zhimg.com/node-snackbar/dist/snackbar.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://unpkg.zhimg.com/@fancyapps/ui/dist/fancybox.css" media="print" onload="this.media='all'"><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?48f01bc27372d79626fe3a9bbfad5af4";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":30,"languages":{"author":"作者: Lfalive","link":"链接: ","source":"来源: Lfalive's Blog","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"你已切换为繁体","cht_to_chs":"你已切换为简体","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#49b1f5","bgDark":"#121212","position":"bottom-left"},
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery@2/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery@2/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: true
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'CS140 - Pintos Projects',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2022-01-25 22:55:16'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.0.0"></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://img.lfalive.top/avatar.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data is-center"><div class="data-item"><a href="/archives/"><div class="headline">文章</div><div class="length-num">33</div></a></div><div class="data-item"><a href="/tags/"><div class="headline">标签</div><div class="length-num">27</div></a></div><div class="data-item"><a href="/categories/"><div class="headline">分类</div><div class="length-num">9</div></a></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://img.lfalive.top/CS140-project/cover.png')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">Lfalive's Blog</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">CS140 - Pintos Projects</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2022-01-18T16:00:00.000Z" title="发表于 2022-01-19 00:00:00">2022-01-19</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2022-01-25T14:55:16.187Z" title="更新于 2022-01-25 22:55:16">2022-01-25</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/concurrency/">concurrency</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">5.3k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>23分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="CS140 - Pintos Projects"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="课程链接"><a href="#课程链接" class="headerlink" title="课程链接"></a>课程链接</h1><p><a target="_blank" rel="noopener" href="https://web.stanford.edu/~ouster/cgi-bin/cs140-spring20/pintosProjects.php">https://web.stanford.edu/~ouster/cgi-bin/cs140-spring20/pintosProjects.php</a></p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/laiy/p/pintos_project1_thread.html">https://www.cnblogs.com/laiy/p/pintos_project1_thread.html</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_43752953/article/details/90248966">https://blog.csdn.net/weixin_43752953/article/details/90248966</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_41680909/article/details/91440122">https://blog.csdn.net/weixin_41680909/article/details/91440122</a></p>
<h1 id="bochs-pintos"><a href="#bochs-pintos" class="headerlink" title="bochs+pintos"></a>bochs+pintos</h1><p>到<a target="_blank" rel="noopener" href="http://bochs.sourceforge.net/">bochs下载地址</a>下载对应版本后，解压，配置，编译，安装。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">wget https://udomain.dl.sourceforge.net/project/bochs/bochs/2.7/bochs-2.7.tar.gz</span><br><span class="line">tar -zxvf bochs-2.7.tar.gz</span><br><span class="line"><span class="built_in">cd</span> bochs-2.7</span><br><span class="line">sudo ./configure --enable-gdb-stub --with-x --with-x11 --with-term --with-nogui</span><br><span class="line">sudo make</span><br><span class="line">sudo make install</span><br></pre></td></tr></table></figure>

<h2 id="报错处理"><a href="#报错处理" class="headerlink" title="报错处理"></a>报错处理</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.bochsrc:197: cpu directive malformed.</span><br></pre></td></tr></table></figure>

<p>打开.bochsrc配置文件，根据行号找到对应错误处。<code>bochs -help cpu</code> 将显示出所有支持的CPU类型。将.bochsrc文件中<code>cpu:model=core2+penryn_t9600</code>的值为上一条查到的所支持的CPU类型之一。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.bochsrc:956: Bochs is not compiled with lowlevel sound support</span><br></pre></td></tr></table></figure>

<p>打开.bochsrc配置文件，注释掉文件中的<code>sound: driver=default, waveout=/dev/dsp. wavein=, midiout=</code>语句。同理，可以注释掉下面的speaker相关配置语句。</p>
<h2 id="安装pintos"><a href="#安装pintos" class="headerlink" title="安装pintos"></a>安装pintos</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">wget https://web.stanford.edu/class/cs140/projects/pintos/pintos.tar.gz</span><br><span class="line">tar -zxvf pintos.tar.gz</span><br></pre></td></tr></table></figure>

<p>遇到权限问题，bochs也各种莫名报错，改bochs为qemu后也疯狂报错。如<code>MoTTY X11 proxy: Unsupported authorisation protocol</code>等。应该是和图形界面相关的什么错。</p>
<p>改Ubuntu虚拟机再从头试试。</p>
<h1 id="qemu-pintos"><a href="#qemu-pintos" class="headerlink" title="qemu+pintos"></a>qemu+pintos</h1><h2 id="参考-1"><a href="#参考-1" class="headerlink" title="参考"></a>参考</h2><p><a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/60696354/cloning-pintos-with-ubuntu">https://stackoverflow.com/questions/60696354/cloning-pintos-with-ubuntu</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/geeeeeker/article/details/108104466">https://blog.csdn.net/geeeeeker/article/details/108104466</a></p>
<p><a target="_blank" rel="noopener" href="https://github.com/kumardeepakr3/PINTOS-Ubuntu">https://github.com/kumardeepakr3/PINTOS-Ubuntu</a></p>
<h2 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h2><p>安装好虚拟机和必须的gcc和g++等，就可以正式开始安装pintos。</p>
<p>首先安装qemu作为模拟器。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt-get install qemu</span><br><span class="line">sudo apt-get install qemu-system-x86</span><br></pre></td></tr></table></figure>

<p>然后从<a target="_blank" rel="noopener" href="https://pintos-os.org/cgi-bin/gitweb.cgi?p=pintos-anon;a=summary">pintos官方库</a>中获取最新的pintos，可以避免一些莫名的bug。这一步当然需要先安装git。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">clone</span> git://pintos-os.org/pintos-anon pintos</span><br></pre></td></tr></table></figure>

<p>然后编辑<code>./pintos/src/utils/pintos-gdb</code>，将<code>GDBMACROS</code>改为系统中对应路径。xxx为示例用户名。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">GDBMACROS=/home/xxx/pintos/src/misc/gdb-macros</span><br></pre></td></tr></table></figure>

<p>这时候在utils文件夹中make，会报错找不到<code>stropts.h</code>。很多人也遇到了这个问题，可能是Ubuntu系统版本的问题，参考中所使用的18.04没有出现该问题。只有一个文件中的几行代码会用到这个库，先注释掉这部分继续编译，后续有问题的话再考虑重新安装Ubuntu18.04。</p>
<p>然后编辑<code>/pintos/src/threads/Make.vars</code>，在第7行左右更改模拟器bochs为qemu。再在<code>/src/threads</code>中make编译线程目录。</p>
<p>紧接着编辑<code>/pintos/src/utils/pintos</code>：</p>
<ul>
<li>103行左右：替换bochs为qemu</li>
<li>621行左右：替换模拟器命令为qemu-system-x86_64</li>
<li>257行左右：替换kernel.bin为完整路径的kernel.bin（threads目录中的kernel.bin）</li>
<li>362行左右：替换$loader_fn变量为完整路径的loader.bin（threads目录中的loader.bin）</li>
</ul>
<p>编辑<code>~/.bashrc</code>，将<code>/pintos/src/utils</code>添加到PATH，即添加如下命令到最后一行。再重新打开终端运行<code>source ~/.bashrc</code>。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">export PATH=/home/.../pintos/src/utils:$PATH</span><br></pre></td></tr></table></figure>

<p>最后在终端输入pintos run alarm-multiple测试，显示如下。</p>
<img src="https://img.lfalive.top/CS140-project/1.png" style="zoom:80%;" />

<h1 id="Alarm-Clock"><a href="#Alarm-Clock" class="headerlink" title="Alarm Clock"></a>Alarm Clock</h1><p>Reimplement <code>timer_sleep()</code>, defined in <code>devices/timer.c</code>. Although a working implementation is provided, it “busy waits,” that is, it spins in a loop checking the current time and calling <code>thread_yield()</code> until enough time has gone by. Reimplement it to avoid busy waiting.</p>
<ul>
<li><p>Function: void <strong>timer_sleep</strong> (int64_t ticks)</p>
<p>Suspends execution of the calling thread until time has advanced by at least x timer ticks. Unless the system is otherwise idle, the thread need not wake up after exactly x ticks. Just put it on the ready queue after they have waited for the right amount of time.<code>timer_sleep()</code> is useful for threads that operate in real-time, e.g. for blinking the cursor once per second.The argument to <code>timer_sleep()</code> is expressed in timer ticks, not in milliseconds or any another unit. There are <code>TIMER_FREQ</code> timer ticks per second, where <code>TIMER_FREQ</code> is a macro defined in <code>devices/timer.h</code>. The default value is 100. We don’t recommend changing this value, because any change is likely to cause many of the tests to fail.</p>
</li>
</ul>
<p>Separate functions <code>timer_msleep()</code>, <code>timer_usleep()</code>, and <code>timer_nsleep()</code> do exist for sleeping a specific number of milliseconds, microseconds, or nanoseconds, respectively, but these will call <code>timer_sleep()</code> automatically when necessary. You do not need to modify them.</p>
<p>If your delays seem too short or too long, reread the explanation of the -r option to <code>pintos</code> (see section <a target="_blank" rel="noopener" href="https://web.stanford.edu/~ouster/cgi-bin/cs140-spring20/pintos/pintos_1.html#SEC6">1.1.4 Debugging versus Testing</a>).</p>
<h2 id="review"><a href="#review" class="headerlink" title="review"></a>review</h2><p>主要看<code>devices/timer.c</code>、<code>threads/interrupt.c</code>和<code>threads/thread.c</code>这几个文件。</p>
<p><code>timer_sleep</code>中，<code>timer_ticks</code>函数获取ticks的当前值返回。<code>intr_get_level</code>返回了<code>intr_level</code>的值。</p>
<p><code>timer_ticks</code>: Returns the number of timer ticks since the OS booted。从pintos被启动开始，ticks就一直在计时。其中中断相关的语句只是确保这个过程不能被中断，即保持这个操作的原子性。</p>
<p><code>intr_disable</code>获取了当前的中断状态，然后将当前中断状态改为不能被中断，然后返回执行之前的中断状态。</p>
<p><code>ASSERT (!intr_context ());</code>断言了intr_context函数返回结果的false，即断言这个中断不是外中断（IO等，也称为硬中断），而是操作系统正常线程切换流程里的内中断（也称为软中断）。</p>
<p><code>thread_schedule_tail</code>获取当前线程，分配恢复之前执行的状态和现场，如果当前线程死了就清空资源。</p>
<p><code>thread_yield</code>把当前线程扔到就绪队列里，然后重新schedule。</p>
<p>总结：<code>timer_sleep</code>就是在ticks时间内，如果线程处于running状态就不断把他扔到就绪队列不让他执行。缺点是线程依然不断在cpu就绪队列和running队列之间来回，占用了cpu资源，我们希望用一种唤醒机制来实现这个函数。</p>
<p>实现思路：调用<code>timer_sleep</code>的时候直接把线程block掉，然后在线程结构体中加一个成员ticks_blocked，用于记录线程被sleep了多久。再利用操作系统自身的，每个tick会执行一次的，时钟中断来检测线程状态。每个tick将ticks_blocked减，如果减到0就表示该线程结束sleep，唤醒这个线程。</p>
<h2 id="devices-x2F-timer-c"><a href="#devices-x2F-timer-c" class="headerlink" title="devices&#x2F;timer.c"></a>devices&#x2F;timer.c</h2><p><img src="https://img.lfalive.top/CS140-project/2.png"></p>
<p>使用old_level保存和恢复中断情况，保证中间操作的原子性。获取当前线程后，设置该线程的ticks_blocked值，并调用thread_block()。</p>
<p><img src="https://img.lfalive.top/CS140-project/3.png"></p>
<p>对于系统自身的中断程序，每个tick的时候对每个线程都执行一次blocked_thread_check（借助foreach函数）。</p>
<h2 id="threads-x2F-thread-h"><a href="#threads-x2F-thread-h" class="headerlink" title="threads&#x2F;thread.h"></a>threads&#x2F;thread.h</h2><p>在thread中加入ticks_blocked成员。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int64_t</span> ticks_blocked; <span class="comment">/* Record the time the thread has been blocked. */</span></span><br></pre></td></tr></table></figure>

<p>声明上文提到的blocked_thread_check函数。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">blocked_thread_check</span> <span class="params">(struct thread *t, <span class="keyword">void</span> *aux UNUSED)</span></span>;</span><br></pre></td></tr></table></figure>

<h2 id="threads-x2F-thread-c"><a href="#threads-x2F-thread-c" class="headerlink" title="threads&#x2F;thread.c"></a>threads&#x2F;thread.c</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Check the blocked thread */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span></span></span><br><span class="line"><span class="function"><span class="title">blocked_thread_check</span> <span class="params">(struct thread *t, <span class="keyword">void</span> *aux UNUSED)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (t-&gt;status == THREAD_BLOCKED &amp;&amp; t-&gt;ticks_blocked &gt; <span class="number">0</span>)</span><br><span class="line">  &#123;</span><br><span class="line">      t-&gt;ticks_blocked--;</span><br><span class="line">      <span class="keyword">if</span> (t-&gt;ticks_blocked == <span class="number">0</span>)</span><br><span class="line">      &#123;</span><br><span class="line">          thread_unblock(t);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>检查是否应该唤醒当前线程。如果该线程状态为Blocked且ticks_blocke值不为0，就将其ticks_blocked递减，如果递减后为0，说明已经sleep到了设定时间，立即将其唤醒。</p>
<h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p>在threads目录中执行<code>make check</code>可以执行所有测试。</p>
<img src="https://img.lfalive.top/CS140-project/result1.png" style="zoom:50%;" />

<h1 id="Priority-Scheduling"><a href="#Priority-Scheduling" class="headerlink" title="Priority Scheduling"></a>Priority Scheduling</h1><p>Implement priority scheduling in Pintos. When a thread is added to the ready list that has a higher priority than the currently running thread, the current thread should immediately yield the processor to the new thread. Similarly, when threads are waiting for a lock, semaphore, or condition variable, the highest priority waiting thread should be awakened first. A thread may raise or lower its own priority at any time, but lowering its priority such that it no longer has the highest priority must cause it to immediately yield the CPU.</p>
<p>Thread priorities range from <code>PRI_MIN</code> (0) to <code>PRI_MAX</code> (63). Lower numbers correspond to lower priorities, so that priority 0 is the lowest priority and priority 63 is the highest. The initial thread priority is passed as an argument to <code>thread_create()</code>. If there’s no reason to choose another priority, use <code>PRI_DEFAULT</code> (31). The <code>PRI_</code> macros are defined in <code>threads/thread.h</code>, and you should not change their values.</p>
<p>One issue with priority scheduling is “priority inversion”. Consider high, medium, and low priority threads H, M, and L, respectively. If H needs to wait for L (for instance, for a lock held by L), and M is on the ready list, then H will never get the CPU because the low priority thread will not get any CPU time. A partial fix for this problem is for H to “donate” its priority to L while L is holding the lock, then recall the donation once L releases (and thus H acquires) the lock.</p>
<p>Implement priority donation. You will need to account for all different situations in which priority donation is required. Be sure to handle multiple donations, in which multiple priorities are donated to a single thread. You must also handle nested donation: if H is waiting on a lock that M holds and M is waiting on a lock that L holds, then both M and L should be boosted to H’s priority. If necessary, you may impose a reasonable limit on depth of nested priority donation, such as 8 levels.</p>
<p>You must implement priority donation for locks. You need not implement priority donation for the other Pintos synchronization constructs. You do need to implement priority scheduling in all cases.</p>
<p>Finally, implement the following functions that allow a thread to examine and modify its own priority. Skeletons for these functions are provided in <code>threads/thread.c</code>.</p>
<ul>
<li><p>Function: void <strong>thread_set_priority</strong> (int new_priority)</p>
<p>Sets the current thread’s priority to new_priority. If the current thread no longer has the highest priority, yields.</p>
</li>
<li><p>Function: int <strong>thread_get_priority</strong> (void)</p>
<p>Returns the current thread’s priority. In the presence of priority donation, returns the higher (donated) priority.</p>
</li>
</ul>
<p>You need not provide any interface to allow a thread to directly modify other threads’ priorities.</p>
<h2 id="review-1"><a href="#review-1" class="headerlink" title="review"></a>review</h2><p>线程结构体本身就有一个priority，其取值范围被限定为[0, 63]，默认值是31。维护就绪队列为一个优先队列可以实现优先级调度。查看源码可以发现<code>thread_unblock</code>、<code>thread_yield</code>函数中有将线程放入ready_list的操作。</p>
<p>查看<code>lib/kernel/list.h</code>文件，发现提供了可以用来维护有序队列的函数。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Operations on lists with ordered elements. */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">list_sort</span> <span class="params">(struct <span class="built_in">list</span> *,</span></span></span><br><span class="line"><span class="params"><span class="function">                list_less_func *, <span class="keyword">void</span> *aux)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">list_insert_ordered</span> <span class="params">(struct <span class="built_in">list</span> *, struct list_elem *,</span></span></span><br><span class="line"><span class="params"><span class="function">                          list_less_func *, <span class="keyword">void</span> *aux)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">list_unique</span> <span class="params">(struct <span class="built_in">list</span> *, struct <span class="built_in">list</span> *duplicates,</span></span></span><br><span class="line"><span class="params"><span class="function">                  list_less_func *, <span class="keyword">void</span> *aux)</span></span>;</span><br></pre></td></tr></table></figure>

<h2 id="pass-alarm-priority"><a href="#pass-alarm-priority" class="headerlink" title="pass alarm-priority"></a>pass alarm-priority</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// list_push_back (&amp;ready_list, &amp;t-&gt;elem);</span></span><br><span class="line">list_insert_ordered (&amp;ready_list, &amp;t-&gt;elem, (list_less_func *) &amp;thread_cmp_priority, <span class="literal">NULL</span>);</span><br></pre></td></tr></table></figure>

<p>将两处<code>list_push_back</code>改写为<code>list_insert_ordered</code>即可。比较函数<code>thread_cmp_priority</code>是自定义的，把优先级数值大的，即优先级大的线程放前面。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* priority compare function. */</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span></span></span><br><span class="line"><span class="function"><span class="title">thread_cmp_priority</span> <span class="params">(<span class="keyword">const</span> struct list_elem *a, <span class="keyword">const</span> struct list_elem *b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> list_entry(a, struct thread, elem)-&gt;priority &gt; list_entry(b, struct thread, elem)-&gt;priority;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>list_entry(LIST_ELEM, STRUCT, MEMBER)</code>定义为<code>((STRUCT *) ((uint8_t *) &amp;(LIST_ELEM)-&gt;next - offsetof (STRUCT, MEMBER.next)))</code>，即将指向list元素list_ELEM的指针转换为指向嵌入list_ELEM的结构体的指针。</p>
<p>这样就通过了alarm-priority测试。</p>
<h2 id="pass-priority-change"><a href="#pass-priority-change" class="headerlink" title="pass priority-change"></a>pass priority-change</h2><p>在某些时候调用<code>thread_yield</code>即可，即把当前线程丢到ready_list中，重新<code>schedule</code>，保证执行顺序。</p>
<ul>
<li>在<code>thread_create</code>中创建线程的时候， 如果新线程比当前线程优先级高的话，调用<code>thread_yield</code>。</li>
<li>在设置任意一个线程优先级时，调用<code>thread_yield</code>，立即重新考虑所有线程执行顺序。</li>
</ul>
<img src="https://img.lfalive.top/CS140-project/create_pri.png" style="zoom:50%;" />

<h2 id="测试-1"><a href="#测试-1" class="headerlink" title="测试"></a>测试</h2><p>同时通过了priority_preempt和priority_fifo。</p>
<img src="https://img.lfalive.top/CS140-project/result2.png" style="zoom:50%;" />

<h2 id="review-remaining-tests"><a href="#review-remaining-tests" class="headerlink" title="review remaining tests"></a>review remaining tests</h2><p><strong>优先级捐赠：</strong>当发现高优先级的任务因为低优先级任务占用资源而阻塞时，就将低优先级任务的优先级提升到等待它所占有的资源的最高优先级任务的优先级。</p>
<p>由priority-donate-one测试代码可知，在一个线程获取一个锁的时候，如果拥有这个锁的线程优先级比自己低就提高它的优先级，然后在这个线程释放掉这个锁之后把原来拥有这个锁的线程改回原来的优先级。</p>
<p>priority-donate-multiple和priority-donate-multiple2是测试多锁情况下优先级逻辑的正确性。释放一个锁的时候，将该锁的拥有者改为该线程被捐赠的第二优先级，若没有其余捐赠者，则恢复原始优先级。那么线程必然需要一个数据结构来记录所有对这个线程有捐赠行为的线程。</p>
<p>priority-donate-nest是一个优先级嵌套问题，重点在于medium请求的锁被low占有，在这个前提下high再去获取medium已拥有的锁，这种情况的优先级提升具有连环效应，就是medium被提升了，此时low线程应该跟着一起提升。需要加一个数据结构，需要获取这个线程请求的锁被哪些线程占有。</p>
<p>priority-donate-sema包含了信号量和锁混合触发，实际上还是信号量在起作用，因为锁是由信号量实现的。</p>
<p>priority-donate-lower测试的逻辑是当修改一个被捐赠的线程优先级的时候的行为正确性。</p>
<p>priority-sema中，信号量V唤醒线程的时候也是先唤醒优先级高的。换句话说，信号量的等待队列是个优先级队列。</p>
<p>priority-condvar同理，condition的waiters队列是个优先级队列。</p>
<p>priority-donate-chain是一个链式优先级捐赠，本质测试的还是多层优先级捐赠逻辑的正确性。需要注意的是一个逻辑：释放掉一个锁之后，如果当前线程不被捐赠即马上改为原来的优先级，抢占式调度。</p>
<p>逻辑总结为：</p>
<ol>
<li><p>一个线程获取一个锁的时候，如果拥有这个锁的线程优先级比自己低，就提高它的优先级，即捐赠优先级。如果这个锁还被别的锁锁着，就递归捐赠优先级，在这个线程释放掉这个锁之后恢复未捐赠逻辑下的优先级。</p>
</li>
<li><p>如果一个线程被多个线程捐赠，将当前的优先级设定为捐赠优先级中的最大值。</p>
</li>
<li><p>在对一个线程进行优先级设置的时候，如果这个线程处于被捐赠状态，则对base_priority进行设置。如果设置的优先级大于当前优先级，则改变当前优先级，否则在捐赠状态取消的时候恢复base_priority。</p>
</li>
<li><p>在释放锁对一个锁优先级有改变的时候，应考虑其余被捐赠优先级和当前优先级，优先级嵌套的问题。</p>
</li>
<li><p>将信号量的waiters队列和condition的waiters队列实现为优先级队列。</p>
</li>
<li><p>释放锁的时候，若优先级改变，可以发生抢占。</p>
</li>
</ol>
<h2 id="synch-c"><a href="#synch-c" class="headerlink" title="synch.c"></a>synch.c</h2><p>在synch.h中的lock结构体中加入成员： </p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_elem</span> <span class="title">elem</span>;</span>      <span class="comment">/* List element for priority donation. */</span></span><br><span class="line"><span class="keyword">int</span> max_priority;     <span class="comment">/* Max priority among the threads acquiring the lock. */</span></span><br></pre></td></tr></table></figure>

<h3 id="锁的获取和释放"><a href="#锁的获取和释放" class="headerlink" title="锁的获取和释放"></a>锁的获取和释放</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span></span></span><br><span class="line"><span class="function"><span class="title">lock_acquire</span> <span class="params">(struct lock *lock)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  ASSERT (lock != <span class="literal">NULL</span>);</span><br><span class="line">  ASSERT (!intr_context ());</span><br><span class="line">  ASSERT (!lock_held_by_current_thread (lock));</span><br><span class="line">  </span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">thread</span> *<span class="title">cur</span> =</span> thread_current ();</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">lock</span> *<span class="title">tmp</span>;</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 锁目前被某个线程占有</span></span><br><span class="line">  <span class="keyword">if</span> (lock-&gt;holder != <span class="literal">NULL</span> &amp;&amp; !thread_mlfqs)</span><br><span class="line">  &#123;</span><br><span class="line">    cur-&gt;lock_waiting = lock;</span><br><span class="line">    tmp = lock;</span><br><span class="line">    <span class="keyword">while</span> (tmp &amp;&amp; cur-&gt;priority &gt; tmp-&gt;max_priority)</span><br><span class="line">    &#123;</span><br><span class="line">      tmp-&gt;max_priority = cur-&gt;priority; <span class="comment">// 提高锁的优先级</span></span><br><span class="line">      thread_donate_priority (tmp-&gt;holder); <span class="comment">// 捐赠优先级给锁的持有线程</span></span><br><span class="line">      tmp = tmp-&gt;holder-&gt;lock_waiting; <span class="comment">//递归处理</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  sema_down (&amp;lock-&gt;semaphore);</span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">enum</span> <span class="title">intr_level</span> <span class="title">old_level</span> =</span> intr_disable ();</span><br><span class="line">  cur = thread_current ();</span><br><span class="line">  <span class="keyword">if</span> (!thread_mlfqs)</span><br><span class="line">  &#123;</span><br><span class="line">    cur-&gt;lock_waiting = <span class="literal">NULL</span>; <span class="comment">//现在不再等待任何锁</span></span><br><span class="line">    lock-&gt;max_priority = cur-&gt;priority; <span class="comment">//锁的最大优先级为当前线程的优先级</span></span><br><span class="line">    thread_hold_the_lock (lock); <span class="comment">//该线程占有该锁</span></span><br><span class="line">  &#125;</span><br><span class="line">  lock-&gt;holder = cur;</span><br><span class="line">  intr_set_level (old_level);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://img.lfalive.top/CS140-project/4.png"></p>
<h3 id="比较函数"><a href="#比较函数" class="headerlink" title="比较函数"></a>比较函数</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span></span></span><br><span class="line"><span class="function"><span class="title">lock_cmp_priority</span> <span class="params">(<span class="keyword">const</span> struct list_elem *a, <span class="keyword">const</span> struct list_elem *b, <span class="keyword">void</span> *aux UNUSED)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> list_entry (a, struct lock, elem)-&gt;max_priority &gt; list_entry (b, struct lock, elem)-&gt;max_priority;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span></span></span><br><span class="line"><span class="function"><span class="title">cond_sema_cmp_priority</span> <span class="params">(<span class="keyword">const</span> struct list_elem *a, <span class="keyword">const</span> struct list_elem *b, <span class="keyword">void</span> *aux UNUSED)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">semaphore_elem</span> *<span class="title">sa</span> =</span> list_entry (a, struct semaphore_elem, elem);</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">semaphore_elem</span> *<span class="title">sb</span> =</span> list_entry (b, struct semaphore_elem, elem);</span><br><span class="line">  <span class="keyword">return</span> list_entry(list_front(&amp;sa-&gt;semaphore.waiters), struct thread, elem)-&gt;priority &gt; list_entry(list_front(&amp;sb-&gt;semaphore.waiters), struct thread, elem)-&gt;priority;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="信号量相关"><a href="#信号量相关" class="headerlink" title="信号量相关"></a>信号量相关</h3><p><img src="https://img.lfalive.top/CS140-project/5.png"></p>
<p><img src="https://img.lfalive.top/CS140-project/6.png"></p>
<h3 id="condition-variable相关"><a href="#condition-variable相关" class="headerlink" title="condition_variable相关"></a>condition_variable相关</h3><p><img src="https://img.lfalive.top/CS140-project/7.png"></p>
<h2 id="thread-c"><a href="#thread-c" class="headerlink" title="thread.c"></a>thread.c</h2><p>在thread结构体中加入如下成员:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> base_priority;               <span class="comment">/* Base priority. */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list</span> <span class="title">locks</span>;</span>               <span class="comment">/* Locks that the thread is holding. */</span>  </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">lock</span> *<span class="title">lock_waiting</span>;</span>      <span class="comment">/* The lock that the thread is waiting for. */</span></span><br></pre></td></tr></table></figure>

<p>在<code>init_thread</code>中加入如下代码：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">t-&gt;base_priority = priority;</span><br><span class="line">list_init (&amp;t-&gt;locks);</span><br><span class="line">t-&gt;lock_waiting = <span class="literal">NULL</span>;</span><br></pre></td></tr></table></figure>

<h3 id="thread-set-priority"><a href="#thread-set-priority" class="headerlink" title="thread_set_priority"></a>thread_set_priority</h3><p><img src="https://img.lfalive.top/CS140-project/8.png"></p>
<h3 id="thread-donate-priority"><a href="#thread-donate-priority" class="headerlink" title="thread_donate_priority"></a>thread_donate_priority</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Donate current priority to thread t. */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span></span></span><br><span class="line"><span class="function"><span class="title">thread_donate_priority</span> <span class="params">(struct thread *t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="class"><span class="keyword">enum</span> <span class="title">intr_level</span> <span class="title">old_level</span> =</span> intr_disable ();</span><br><span class="line">  thread_update_priority (t);</span><br><span class="line"></span><br><span class="line">  <span class="comment">//更新ready_list队列</span></span><br><span class="line">  <span class="keyword">if</span> (t-&gt;status == THREAD_READY)</span><br><span class="line">  &#123;</span><br><span class="line">    list_remove (&amp;t-&gt;elem);</span><br><span class="line">    list_insert_ordered (&amp;ready_list, &amp;t-&gt;elem, thread_cmp_priority, <span class="literal">NULL</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  intr_set_level (old_level);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="thread-hold-the-lock"><a href="#thread-hold-the-lock" class="headerlink" title="thread_hold_the_lock"></a>thread_hold_the_lock</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Let thread hold a lock */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span></span></span><br><span class="line"><span class="function"><span class="title">thread_hold_the_lock</span><span class="params">(struct lock *lock)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="class"><span class="keyword">enum</span> <span class="title">intr_level</span> <span class="title">old_level</span> =</span> intr_disable ();</span><br><span class="line">  list_insert_ordered (&amp;thread_current ()-&gt;locks, &amp;lock-&gt;elem, lock_cmp_priority, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (lock-&gt;max_priority &gt; thread_current ()-&gt;priority) <span class="comment">//锁的优先级&gt;当前线程的优先级</span></span><br><span class="line">  &#123;</span><br><span class="line">    thread_current ()-&gt;priority = lock-&gt;max_priority; <span class="comment">//提高当前线程优先级</span></span><br><span class="line">    thread_yield (); <span class="comment">//重新调度</span></span><br><span class="line">  &#125;</span><br><span class="line">  intr_set_level (old_level);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="thread-remove-lock"><a href="#thread-remove-lock" class="headerlink" title="thread_remove_lock"></a>thread_remove_lock</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Remove a lock. */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span></span></span><br><span class="line"><span class="function"><span class="title">thread_remove_lock</span> <span class="params">(struct lock *lock)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="class"><span class="keyword">enum</span> <span class="title">intr_level</span> <span class="title">old_level</span> =</span> intr_disable ();</span><br><span class="line">  list_remove (&amp;lock-&gt;elem); <span class="comment">//把锁从list中删除</span></span><br><span class="line">  thread_update_priority (thread_current ()); <span class="comment">//更新优先级</span></span><br><span class="line">  intr_set_level (old_level);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="thread-update-priority"><a href="#thread-update-priority" class="headerlink" title="thread_update_priority"></a>thread_update_priority</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Update priority. */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span></span></span><br><span class="line"><span class="function"><span class="title">thread_update_priority</span> <span class="params">(struct thread *t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="class"><span class="keyword">enum</span> <span class="title">intr_level</span> <span class="title">old_level</span> =</span> intr_disable ();</span><br><span class="line">  <span class="keyword">int</span> max_priority = t-&gt;base_priority;</span><br><span class="line">  <span class="keyword">int</span> lock_priority;</span><br><span class="line">  <span class="comment">//如果该线程正占有某个锁，就取用其优先级最高的和线程被捐赠的最高优先级相比较</span></span><br><span class="line">  <span class="keyword">if</span> (!list_empty (&amp;t-&gt;locks))</span><br><span class="line">  &#123;</span><br><span class="line">    list_sort (&amp;t-&gt;locks, lock_cmp_priority, <span class="literal">NULL</span>);</span><br><span class="line">    lock_priority = list_entry (list_front (&amp;t-&gt;locks), struct lock, elem)-&gt;max_priority;</span><br><span class="line">    <span class="keyword">if</span> (lock_priority &gt; max_priority)</span><br><span class="line">      max_priority = lock_priority;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  t-&gt;priority = max_priority;</span><br><span class="line">  intr_set_level (old_level);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="再测试"><a href="#再测试" class="headerlink" title="再测试"></a>再测试</h2><img src="https://img.lfalive.top/CS140-project/result3.png" style="zoom:50%;" />

<h1 id="Advanced-Scheduler"><a href="#Advanced-Scheduler" class="headerlink" title="Advanced Scheduler"></a>Advanced Scheduler</h1><p>Implement a multilevel feedback queue scheduler similar to the 4.4BSD scheduler to reduce the average response time for running jobs on your system. See section <a target="_blank" rel="noopener" href="https://web.stanford.edu/~ouster/cgi-bin/cs140-spring20/pintos/pintos_7.html#SEC131">B. 4.4BSD Scheduler</a>, for detailed requirements.</p>
<p>Like the priority scheduler, the advanced scheduler chooses the thread to run based on priorities. However, the advanced scheduler does not do priority donation. Thus, we recommend that you have the priority scheduler working, except possibly for priority donation, before you start work on the advanced scheduler.</p>
<p>You must write your code to allow us to choose a scheduling algorithm policy at Pintos startup time. By default, the priority scheduler must be active, but we must be able to choose the 4.4BSD scheduler with the -mlfqs kernel option. Passing this option sets <code>thread_mlfqs</code>, declared in <code>threads/thread.h</code>, to true when the options are parsed by <code>parse_options()</code>, which happens early in <code>main()</code>.</p>
<p>When the 4.4BSD scheduler is enabled, threads no longer directly control their own priorities. The priority argument to <code>thread_create()</code> should be ignored, as well as any calls to <code>thread_set_priority()</code>, and <code>thread_get_priority()</code> should return the thread’s current priority as set by the scheduler.</p>
<h2 id="计算公式"><a href="#计算公式" class="headerlink" title="计算公式"></a>计算公式</h2><p><a target="_blank" rel="noopener" href="https://web.stanford.edu/~ouster/cgi-bin/cs140-spring20/pintos/pintos_7.html#SEC131">计算公式指导书</a></p>
<p>以下公式总结了实现调度程序所需的计算，但不是调度程序要求的完整描述。</p>
<p>每个线程在其控制下都有一个介于-20和20之间的<code>nice</code>值。每个线程还有一个优先级，介于<code>0(PRI_MIN)</code>到<code>63(PRI_MAX)</code>之间，每四个tick使用以下公式重新计算一次：</p>
<center><b>priority = PRI_MAX - (recent_cpu/4) - (nice*2)</b></center>

<p><code>recent_cpu</code>测量线程“最近“收到的CPU数。在每个计时器tick中，正在运行的线程的<code>recent_cpu</code>增加1。每个线程的<code>recent_cpu</code>以这种方式每秒更新一次：</p>
<center><b>recent_cpu = (2*load_avg) / (2*load_avg + 1) * recent_cpu + nice</b></center>

<p><code>load_avg</code>估计过去一分钟就绪的平均线程数，它在启动时初始化为0，并每秒重新计算一次，如下所示：</p>
<center><b>load_avg = (59/60) * load_avg + (1/60) * ready_threads</b></center>

<p>其中<code>ready_threads</code>是正在运行或就绪的线程数（不包括空闲线程）。</p>
<h2 id="浮点数运算规则"><a href="#浮点数运算规则" class="headerlink" title="浮点数运算规则"></a>浮点数运算规则</h2><p>The following table summarizes how fixed-point arithmetic operations can be implemented in C. In the table, <code>x</code> and <code>y</code> are fixed-point numbers, <code>n</code> is an integer, fixed-point numbers are in signed p.q format where p + q &#x3D; 31, and <code>f</code> is <code>1 &lt;&lt; q</code> ：</p>
<table>
<thead>
<tr>
<th>Description</th>
<th>Expression</th>
</tr>
</thead>
<tbody><tr>
<td>Convert <code>n</code> to fixed point:</td>
<td><code>n * f</code></td>
</tr>
<tr>
<td>Convert <code>x</code> to integer (rounding toward zero):</td>
<td><code>x / f</code></td>
</tr>
<tr>
<td>Convert <code>x</code> to integer (rounding to nearest):</td>
<td><code>(x + f / 2) / f</code> if <code>x &gt;= 0</code>,  <code>(x - f / 2) / f</code> if <code>x &lt;= 0</code>.</td>
</tr>
<tr>
<td>Add <code>x</code> and <code>y</code>:</td>
<td><code>x + y</code></td>
</tr>
<tr>
<td>Subtract <code>y</code> from <code>x</code>:</td>
<td><code>x - y</code></td>
</tr>
<tr>
<td>Add <code>x</code> and <code>n</code>:</td>
<td><code>x + n * f</code></td>
</tr>
<tr>
<td>Subtract <code>n</code> from <code>x</code>:</td>
<td><code>x - n * f</code></td>
</tr>
<tr>
<td>Multiply <code>x</code> by <code>y</code>:</td>
<td><code>((int64_t) x) * y / f</code></td>
</tr>
<tr>
<td>Multiply <code>x</code> by <code>n</code>:</td>
<td><code>x * n</code></td>
</tr>
<tr>
<td>Divide <code>x</code> by <code>y</code>:</td>
<td><code>((int64_t) x) * f / y</code></td>
</tr>
<tr>
<td>Divide <code>x</code> by <code>n</code>:</td>
<td><code>x / n</code></td>
</tr>
</tbody></table>
<h2 id="devices-x2F-timer-c-1"><a href="#devices-x2F-timer-c-1" class="headerlink" title="devices&#x2F;timer.c"></a>devices&#x2F;timer.c</h2><p>在<code>timer_interrupt</code>中，每<code>TIMER_FREQ</code>时间（系统默认值是100）更新一次系统<code>load_avg</code>和所有线程的<code>recent_cpu</code>；每4个ticks更新一次线程优先级；每个timer_tick，running线程的<code>recent_cpu</code>递增。本质上还是优先级调度，保留之前写的优先级调度代码，在优先级捐赠相关函数中加<code>thread_mlfqs</code>判断。在<code>timer_interrupt</code>函数中加入如下代码。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (thread_mlfqs)</span><br><span class="line">&#123;</span><br><span class="line">  thread_mlfqs_increase_recent_cpu ();</span><br><span class="line">  <span class="keyword">if</span> (ticks % TIMER_FREQ == <span class="number">0</span>) thread_mlfqs_update_load_avg_and_recent_cpu ();</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (ticks % <span class="number">4</span> == <span class="number">0</span>) thread_mlfqs_update_priority (thread_current ());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="threads-x2F-thread-c-1"><a href="#threads-x2F-thread-c-1" class="headerlink" title="threads&#x2F;thread.c"></a>threads&#x2F;thread.c</h2><p>在thread结构体中加入int成员<code>nice</code>和<code>recent_cpu</code>。然后在<code>init_thread</code>中进行初始化。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">t-&gt;nice = <span class="number">0</span>;</span><br><span class="line">t-&gt;recent_cpu = FP_CONST (<span class="number">0</span>);</span><br></pre></td></tr></table></figure>

<p>定义全局变量<code>static int load_avg;</code>，然后在<code>thread_init</code>中将其初始化<code>load_avg = FP_CONST (0);</code>。</p>
<h3 id="浮点数运算"><a href="#浮点数运算" class="headerlink" title="浮点数运算"></a>浮点数运算</h3><p>在代码靠前位置加入浮点数运算相关的定义。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 浮点运算相关 */</span></span><br><span class="line"><span class="comment">/* Convert a value to fixed-point value. */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FP_CONST(A) ((int)(A &lt;&lt; 16))</span></span><br><span class="line"><span class="comment">/* Add two fixed-point value. */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FP_ADD(A,B) (A + B)</span></span><br><span class="line"><span class="comment">/* Add a fixed-point value A and an int value B. */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FP_ADD_MIX(A,B) (A + (B &lt;&lt; 16))</span></span><br><span class="line"><span class="comment">/* Substract two fixed-point value. */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FP_SUB(A,B) (A - B)</span></span><br><span class="line"><span class="comment">/* Substract an int value B from a fixed-point value A */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FP_SUB_MIX(A,B) (A - (B &lt;&lt; 16))</span></span><br><span class="line"><span class="comment">/* Multiply a fixed-point value A by an int value B. */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FP_MULT_MIX(A,B) (A * B)</span></span><br><span class="line"><span class="comment">/* Divide a fixed-point value A by an int value B. */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FP_DIV_MIX(A,B) (A / B)</span></span><br><span class="line"><span class="comment">/* Multiply two fixed-point value. */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FP_MULT(A,B) ((int)(((int64_t) A) * B &gt;&gt; 16))</span></span><br><span class="line"><span class="comment">/* Divide two fixed-point value. */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FP_DIV(A,B) ((int)((((int64_t) A) &lt;&lt; 16) / B))</span></span><br><span class="line"><span class="comment">/* Get integer part of a fixed-point value. */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FP_INT_PART(A) (A &gt;&gt; 16)</span></span><br><span class="line"><span class="comment">/* Get rounded integer of a fixed-point value. */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FP_ROUND(A) (A &gt;= 0 ? ((A + (1 <span class="meta-string">&lt;&lt; (16 - 1))) &gt;</span>&gt; 16) : ((A - (1 <span class="meta-string">&lt;&lt; (16 - 1))) &gt;</span>&gt; 16))</span></span><br></pre></td></tr></table></figure>

<p>这里用低16位数作为浮点数的小数部分，无论什么运算一定要维持整数部分从第17位开始。</p>
<h3 id="recent-cpu-amp-load-avg"><a href="#recent-cpu-amp-load-avg" class="headerlink" title="recent_cpu &amp; load_avg"></a>recent_cpu &amp; load_avg</h3><p><code>timer_interrupt</code>中涉及的三个函数如下，分别是递增<code>recent_cpu</code>、更新优先级、更新<code>load_avg</code>及<code>recent_cpu</code>。计算逻辑即参考公式。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Update priority. */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span></span></span><br><span class="line"><span class="function"><span class="title">thread_mlfqs_update_priority</span> <span class="params">(struct thread *t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (t == idle_thread) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">  ASSERT (thread_mlfqs);</span><br><span class="line">  <span class="comment">/* 计算priority */</span></span><br><span class="line">  t-&gt;priority = FP_INT_PART (FP_SUB_MIX (FP_SUB (FP_CONST (PRI_MAX), FP_DIV_MIX (t-&gt;recent_cpu, <span class="number">4</span>)), <span class="number">2</span> * t-&gt;nice));</span><br><span class="line">  t-&gt;priority = t-&gt;priority &lt; PRI_MIN ? PRI_MIN : t-&gt;priority;</span><br><span class="line">  t-&gt;priority = t-&gt;priority &gt; PRI_MAX ? PRI_MAX : t-&gt;priority;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Increase recent_cpu by 1. */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span></span></span><br><span class="line"><span class="function"><span class="title">thread_mlfqs_increase_recent_cpu</span> <span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  ASSERT (thread_mlfqs);</span><br><span class="line">  ASSERT (intr_context ());</span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">thread</span> *<span class="title">current_thread</span> =</span> thread_current ();</span><br><span class="line">  <span class="keyword">if</span> (current_thread == idle_thread) <span class="keyword">return</span>;</span><br><span class="line">  current_thread-&gt;recent_cpu = FP_ADD_MIX (current_thread-&gt;recent_cpu, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Every per second to refresh load_avg and recent_cpu of all threads. */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span></span></span><br><span class="line"><span class="function"><span class="title">thread_mlfqs_update_load_avg_and_recent_cpu</span> <span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  ASSERT (thread_mlfqs);</span><br><span class="line">  ASSERT (intr_context ());</span><br><span class="line">  <span class="comment">/* 计算ready_threads */</span></span><br><span class="line">  <span class="keyword">size_t</span> ready_threads = list_size (&amp;ready_list);</span><br><span class="line">  <span class="keyword">if</span> (thread_current () != idle_thread) ready_threads++;</span><br><span class="line">  <span class="comment">/* 计算load_avg */</span></span><br><span class="line">  load_avg = FP_ADD (FP_DIV_MIX (FP_MULT_MIX (load_avg, <span class="number">59</span>), <span class="number">60</span>), FP_DIV_MIX (FP_CONST (ready_threads), <span class="number">60</span>));</span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">thread</span> *<span class="title">t</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">list_elem</span> *<span class="title">e</span> =</span> list_begin (&amp;all_list);</span><br><span class="line">  <span class="comment">/* update recent_cpu */</span></span><br><span class="line">  <span class="keyword">while</span> (e != list_end (&amp;all_list))</span><br><span class="line">  &#123;</span><br><span class="line">    t = list_entry(e, struct thread, allelem);</span><br><span class="line">    <span class="keyword">if</span> (t != idle_thread)</span><br><span class="line">    &#123;</span><br><span class="line">      t-&gt;recent_cpu = FP_ADD_MIX (FP_MULT (FP_DIV (FP_MULT_MIX (load_avg, <span class="number">2</span>), FP_ADD_MIX (FP_MULT_MIX (load_avg, <span class="number">2</span>), <span class="number">1</span>)), t-&gt;recent_cpu), t-&gt;nice);</span><br><span class="line">      thread_mlfqs_update_priority (t);</span><br><span class="line">    &#125;</span><br><span class="line">    e = list_next (e);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后完善头文件中已经写好的几个函数原型。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Sets the current thread&#x27;s nice value to NICE. */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span></span></span><br><span class="line"><span class="function"><span class="title">thread_set_nice</span> <span class="params">(<span class="keyword">int</span> nice UNUSED)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  thread_current ()-&gt;nice = nice;</span><br><span class="line">  thread_mlfqs_update_priority (thread_current ());</span><br><span class="line">  thread_yield (); <span class="comment">//重新调度</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Returns the current thread&#x27;s nice value. */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span></span></span><br><span class="line"><span class="function"><span class="title">thread_get_nice</span> <span class="params">(<span class="keyword">void</span>)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> thread_current ()-&gt;nice;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Returns 100 times the system load average. */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span></span></span><br><span class="line"><span class="function"><span class="title">thread_get_load_avg</span> <span class="params">(<span class="keyword">void</span>)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> FP_ROUND (FP_MULT_MIX (load_avg, <span class="number">100</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Returns 100 times the current thread&#x27;s recent_cpu value. */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span></span></span><br><span class="line"><span class="function"><span class="title">thread_get_recent_cpu</span> <span class="params">(<span class="keyword">void</span>)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> FP_ROUND (FP_MULT_MIX (thread_current ()-&gt;recent_cpu, <span class="number">100</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="测试-2"><a href="#测试-2" class="headerlink" title="测试"></a>测试</h2><p>测试的时候，发现mlfqs测试的默认时限为60s，测试时很容易因为超时而终止，暂不清楚这与模拟器是qemu&#x2F;bochs是否有关。以运行mlfqs-load-60为例，需要计算180s左右的load。Timer在整个程序执行过程中经历了18827个tick，约为188s。</p>
<img src="https://img.lfalive.top/CS140-project/9.png" style="zoom: 50%;" />

<p>此时，修改tests&#x2F;Make.tests文件末尾的TIMEOUT参数，把默认值60改掉（如改为200）后，测试可以通过。</p>
<img src="https://img.lfalive.top/CS140-project/10.png" style="zoom:50%;" />

<p>最终测试结果如下：</p>
<img src="https://img.lfalive.top/CS140-project/result4.png" style="zoom:50%;" />

</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">Lfalive</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://lfalive.github.io/2022/01/19/CS140-project/">https://lfalive.github.io/2022/01/19/CS140-project/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://lfalive.github.io" target="_blank">Lfalive's Blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/concurrency/">concurrency</a><a class="post-meta__tags" href="/tags/stanford/">stanford</a><a class="post-meta__tags" href="/tags/pintos/">pintos</a><a class="post-meta__tags" href="/tags/bochs/">bochs</a><a class="post-meta__tags" href="/tags/qemu/">qemu</a></div><div class="post_share"><div class="social-share" data-image="https://img.lfalive.top/CS140-project/cover.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://unpkg.zhimg.com/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://unpkg.zhimg.com/social-share.js/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button"><i class="fas fa-qrcode"></i> 打赏</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="https://img.lfalive.top/alipay.jpg" target="_blank"><img class="post-qr-code-img" src="https://img.lfalive.top/alipay.jpg" alt="alipay"/></a><div class="post-qr-code-desc">alipay</div></li></ul></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2022/01/10/CSAPP-plus/"><img class="prev-cover" src="https://img.lfalive.top/CSAPP-datalab/cover.jpeg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">CSAPP相关若干问题的补充整理</div></div></a></div><div class="next-post pull-right"><a href="/2022/01/28/CS149-asst2/"><img class="next-cover" src="https://img.lfalive.top/CS149-asst2/cover.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">CS149 - Programming Assignments 2</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2022/01/28/CS149-asst2/" title="CS149 - Programming Assignments 2"><img class="cover" src="https://img.lfalive.top/CS149-asst2/cover.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-01-28</div><div class="title">CS149 - Programming Assignments 2</div></div></a></div><div><a href="/2022/01/06/Classic-Concurrency-Problems/" title="并发经典问题的实现"><img class="cover" src="https://img.lfalive.top/Classic-Concurrency-Problems/cover.jpeg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-01-06</div><div class="title">并发经典问题的实现</div></div></a></div><div><a href="/2022/01/04/LeetCode-Concurrency/" title="LeetCode多线程练习"><img class="cover" src="https://img.lfalive.top/LeetCode-Concurrency/cover.jpeg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-01-04</div><div class="title">LeetCode多线程练习</div></div></a></div></div></div><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="twikoo-wrap"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://img.lfalive.top/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">Lfalive</div><div class="author-info__description">Studying at HUST.</div></div><div class="card-info-data is-center"><div class="card-info-data-item"><a href="/archives/"><div class="headline">文章</div><div class="length-num">33</div></a></div><div class="card-info-data-item"><a href="/tags/"><div class="headline">标签</div><div class="length-num">27</div></a></div><div class="card-info-data-item"><a href="/categories/"><div class="headline">分类</div><div class="length-num">9</div></a></div></div><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/lfalive" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="mailto:542679373@qq.com" target="_blank" title="Email"><i class="far fa-envelope"></i></a><a class="social-icon" href="https://instagram.com/lfalive_cn" target="_blank" title="Instagram"><i class="fab fa-instagram"></i></a><a class="social-icon" href="https://steamcommunity.com/profiles/76561198452723298" target="_blank" title="Steam"><i class="fab fa-steam"></i></a><a class="social-icon" href="https://www.hust.edu.cn/" target="_blank" title="HUST"><i class="fas fa-graduation-cap"></i></a></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%AF%BE%E7%A8%8B%E9%93%BE%E6%8E%A5"><span class="toc-number">1.</span> <span class="toc-text">课程链接</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%82%E8%80%83"><span class="toc-number">1.1.</span> <span class="toc-text">参考</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#bochs-pintos"><span class="toc-number">2.</span> <span class="toc-text">bochs+pintos</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8A%A5%E9%94%99%E5%A4%84%E7%90%86"><span class="toc-number">2.1.</span> <span class="toc-text">报错处理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%89%E8%A3%85pintos"><span class="toc-number">2.2.</span> <span class="toc-text">安装pintos</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#qemu-pintos"><span class="toc-number">3.</span> <span class="toc-text">qemu+pintos</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%82%E8%80%83-1"><span class="toc-number">3.1.</span> <span class="toc-text">参考</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%AD%A5%E9%AA%A4"><span class="toc-number">3.2.</span> <span class="toc-text">步骤</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Alarm-Clock"><span class="toc-number">4.</span> <span class="toc-text">Alarm Clock</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#review"><span class="toc-number">4.1.</span> <span class="toc-text">review</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#devices-x2F-timer-c"><span class="toc-number">4.2.</span> <span class="toc-text">devices&#x2F;timer.c</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#threads-x2F-thread-h"><span class="toc-number">4.3.</span> <span class="toc-text">threads&#x2F;thread.h</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#threads-x2F-thread-c"><span class="toc-number">4.4.</span> <span class="toc-text">threads&#x2F;thread.c</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B5%8B%E8%AF%95"><span class="toc-number">4.5.</span> <span class="toc-text">测试</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Priority-Scheduling"><span class="toc-number">5.</span> <span class="toc-text">Priority Scheduling</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#review-1"><span class="toc-number">5.1.</span> <span class="toc-text">review</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#pass-alarm-priority"><span class="toc-number">5.2.</span> <span class="toc-text">pass alarm-priority</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#pass-priority-change"><span class="toc-number">5.3.</span> <span class="toc-text">pass priority-change</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B5%8B%E8%AF%95-1"><span class="toc-number">5.4.</span> <span class="toc-text">测试</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#review-remaining-tests"><span class="toc-number">5.5.</span> <span class="toc-text">review remaining tests</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#synch-c"><span class="toc-number">5.6.</span> <span class="toc-text">synch.c</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%94%81%E7%9A%84%E8%8E%B7%E5%8F%96%E5%92%8C%E9%87%8A%E6%94%BE"><span class="toc-number">5.6.1.</span> <span class="toc-text">锁的获取和释放</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%AF%94%E8%BE%83%E5%87%BD%E6%95%B0"><span class="toc-number">5.6.2.</span> <span class="toc-text">比较函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BF%A1%E5%8F%B7%E9%87%8F%E7%9B%B8%E5%85%B3"><span class="toc-number">5.6.3.</span> <span class="toc-text">信号量相关</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#condition-variable%E7%9B%B8%E5%85%B3"><span class="toc-number">5.6.4.</span> <span class="toc-text">condition_variable相关</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#thread-c"><span class="toc-number">5.7.</span> <span class="toc-text">thread.c</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#thread-set-priority"><span class="toc-number">5.7.1.</span> <span class="toc-text">thread_set_priority</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#thread-donate-priority"><span class="toc-number">5.7.2.</span> <span class="toc-text">thread_donate_priority</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#thread-hold-the-lock"><span class="toc-number">5.7.3.</span> <span class="toc-text">thread_hold_the_lock</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#thread-remove-lock"><span class="toc-number">5.7.4.</span> <span class="toc-text">thread_remove_lock</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#thread-update-priority"><span class="toc-number">5.7.5.</span> <span class="toc-text">thread_update_priority</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%86%8D%E6%B5%8B%E8%AF%95"><span class="toc-number">5.8.</span> <span class="toc-text">再测试</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Advanced-Scheduler"><span class="toc-number">6.</span> <span class="toc-text">Advanced Scheduler</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AE%A1%E7%AE%97%E5%85%AC%E5%BC%8F"><span class="toc-number">6.1.</span> <span class="toc-text">计算公式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B5%AE%E7%82%B9%E6%95%B0%E8%BF%90%E7%AE%97%E8%A7%84%E5%88%99"><span class="toc-number">6.2.</span> <span class="toc-text">浮点数运算规则</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#devices-x2F-timer-c-1"><span class="toc-number">6.3.</span> <span class="toc-text">devices&#x2F;timer.c</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#threads-x2F-thread-c-1"><span class="toc-number">6.4.</span> <span class="toc-text">threads&#x2F;thread.c</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B5%AE%E7%82%B9%E6%95%B0%E8%BF%90%E7%AE%97"><span class="toc-number">6.4.1.</span> <span class="toc-text">浮点数运算</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#recent-cpu-amp-load-avg"><span class="toc-number">6.4.2.</span> <span class="toc-text">recent_cpu &amp; load_avg</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B5%8B%E8%AF%95-2"><span class="toc-number">6.5.</span> <span class="toc-text">测试</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2022/01/28/CS149-asst2/" title="CS149 - Programming Assignments 2"><img src="https://img.lfalive.top/CS149-asst2/cover.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="CS149 - Programming Assignments 2"/></a><div class="content"><a class="title" href="/2022/01/28/CS149-asst2/" title="CS149 - Programming Assignments 2">CS149 - Programming Assignments 2</a><time datetime="2022-01-27T16:00:00.000Z" title="发表于 2022-01-28 00:00:00">2022-01-28</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/01/19/CS140-project/" title="CS140 - Pintos Projects"><img src="https://img.lfalive.top/CS140-project/cover.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="CS140 - Pintos Projects"/></a><div class="content"><a class="title" href="/2022/01/19/CS140-project/" title="CS140 - Pintos Projects">CS140 - Pintos Projects</a><time datetime="2022-01-18T16:00:00.000Z" title="发表于 2022-01-19 00:00:00">2022-01-19</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/01/10/CSAPP-plus/" title="CSAPP相关若干问题的补充整理"><img src="https://img.lfalive.top/CSAPP-datalab/cover.jpeg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="CSAPP相关若干问题的补充整理"/></a><div class="content"><a class="title" href="/2022/01/10/CSAPP-plus/" title="CSAPP相关若干问题的补充整理">CSAPP相关若干问题的补充整理</a><time datetime="2022-01-09T16:00:00.000Z" title="发表于 2022-01-10 00:00:00">2022-01-10</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/01/06/Classic-Concurrency-Problems/" title="并发经典问题的实现"><img src="https://img.lfalive.top/Classic-Concurrency-Problems/cover.jpeg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="并发经典问题的实现"/></a><div class="content"><a class="title" href="/2022/01/06/Classic-Concurrency-Problems/" title="并发经典问题的实现">并发经典问题的实现</a><time datetime="2022-01-05T16:00:00.000Z" title="发表于 2022-01-06 00:00:00">2022-01-06</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/01/04/LeetCode-Concurrency/" title="LeetCode多线程练习"><img src="https://img.lfalive.top/LeetCode-Concurrency/cover.jpeg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="LeetCode多线程练习"/></a><div class="content"><a class="title" href="/2022/01/04/LeetCode-Concurrency/" title="LeetCode多线程练习">LeetCode多线程练习</a><time datetime="2022-01-03T16:00:00.000Z" title="发表于 2022-01-04 00:00:00">2022-01-04</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url('https://img.lfalive.top/CS140-project/cover.png')"><div id="footer-wrap"><div class="copyright">&copy;2018 - 2022 By Lfalive</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text"><a target="_blank" rel="noopener" href="https://beian.miit.gov.cn/"><span>渝ICP备19015268号</span></a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">本地搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div></div></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://unpkg.zhimg.com/@fancyapps/ui/dist/fancybox.umd.js"></script><script src="https://cdn.bootcdn.net/ajax/libs/instant.page/5.1.0/instantpage.min.js" type="module"></script><script src="https://unpkg.zhimg.com/node-snackbar/dist/snackbar.min.js"></script><script src="/js/search/local-search.js"></script><script>var preloader = {
  endLoading: () => {
    document.body.style.overflow = 'auto';
    document.getElementById('loading-box').classList.add("loaded")
  },
  initLoading: () => {
    document.body.style.overflow = '';
    document.getElementById('loading-box').classList.remove("loaded")

  }
}
window.addEventListener('load',preloader.endLoading())</script><div class="js-pjax"><script>(()=>{
  const init = () => {
    twikoo.init(Object.assign({
      el: '#twikoo-wrap',
      envId: 'twikoo-6gga64kp7c17697e',
      region: '',
      onCommentLoaded: function () {
        btf.loadLightbox(document.querySelectorAll('#twikoo .tk-content img:not(.vemoji)'))
      }
    }, null))
  }

  const getCount = () => {
    twikoo.getCommentsCount({
      envId: 'twikoo-6gga64kp7c17697e',
      region: '',
      urls: [window.location.pathname],
      includeReply: false
    }).then(function (res) {
      document.getElementById('twikoo-count').innerText = res[0].count
    }).catch(function (err) {
      console.error(err);
    });
  }

  const runFn = () => {
    init()
    GLOBAL_CONFIG_SITE.isPost && getCount()
  }

  const loadTwikoo = () => {
    if (typeof twikoo === 'object') {
      setTimeout(runFn,0)
      return
    } 
    getScript('https://unpkg.zhimg.com/twikoo@1.4.15/dist/twikoo.all.min.js').then(runFn)
  }

  if ('Twikoo' === 'Twikoo' || !true) {
    if (true) btf.loadComment(document.getElementById('twikoo-wrap'), loadTwikoo)
    else loadTwikoo()
  } else {
    window.loadOtherComment = () => {
      loadTwikoo()
    }
  }
})()</script></div><div class="aplayer no-destroy" data-id="003zngCA4Gbjv4" data-server="tencent" data-type="song" data-fixed="true" data-mini="true" data-listFolded="false" data-loop="one" data-preload="none" data-autoplay="false" muted></div><script defer="defer" id="fluttering_ribbon" mobile="false" src="https://unpkg.zhimg.com/butterfly-extsrc@1/dist/canvas-fluttering-ribbon.min.js"></script><script src="https://unpkg.zhimg.com/butterfly-extsrc@1/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = false;
POWERMODE.mobile = false;
document.body.addEventListener('input', POWERMODE);
</script><link rel="stylesheet" href="https://img.lfalive.top/Aplayer/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://img.lfalive.top/Aplayer/APlayer.min.js"></script><script src="https://img.lfalive.top/Aplayer/Meting.min.js"></script><script src="https://unpkg.zhimg.com/pjax/pjax.min.js"></script><script>let pjaxSelectors = ["title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]

var pjax = new Pjax({
  elements: 'a:not([target="_blank"])',
  selectors: pjaxSelectors,
  cacheBust: false,
  analytics: false,
  scrollRestoration: false
})

document.addEventListener('pjax:send', function () {

  // removeEventListener scroll 
  window.tocScrollFn && window.removeEventListener('scroll', window.tocScrollFn)
  window.scrollCollect && window.removeEventListener('scroll', scrollCollect)

  typeof preloader === 'object' && preloader.initLoading()
  document.getElementById('rightside').style.cssText = "opacity: ''; transform: ''"
  
  if (window.aplayers) {
    for (let i = 0; i < window.aplayers.length; i++) {
      if (!window.aplayers[i].options.fixed) {
        window.aplayers[i].destroy()
      }
    }
  }

  typeof typed === 'object' && typed.destroy()

  //reset readmode
  const $bodyClassList = document.body.classList
  $bodyClassList.contains('read-mode') && $bodyClassList.remove('read-mode')

})

document.addEventListener('pjax:complete', function () {
  window.refreshFn()

  document.querySelectorAll('script[data-pjax]').forEach(item => {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
  })

  GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

  typeof chatBtnFn === 'function' && chatBtnFn()
  typeof panguInit === 'function' && panguInit()

  // google analytics
  typeof gtag === 'function' && gtag('config', '', {'page_path': window.location.pathname});

  // baidu analytics
  typeof _hmt === 'object' && _hmt.push(['_trackPageview',window.location.pathname]);

  typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()

  // prismjs
  typeof Prism === 'object' && Prism.highlightAll()

  typeof preloader === 'object' && preloader.endLoading()
})

document.addEventListener('pjax:error', (e) => {
  if (e.request.status === 404) {
    pjax.loadUrl('/404.html')
  }
})</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>